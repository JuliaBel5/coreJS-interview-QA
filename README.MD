<h3>
  <span>JavaScript Core</span>
</h3>

- [Browser JS/TS](#browser-jsts)
  - [JavaScript](#javascript)
    - [Циклы `while` и `for`](#циклы-while-и-for)
    - [Условие `if`](#условие-if)
    - [Конструкция `switch`](#конструкция-switch)
    - [Логические операторы](#логические-операторы)
    - [Условные операторы](#условные-операторы)
    - [Alert/prompt/confirm](#alertpromptconfirm)
    - [Различия между `let`, `const` и `var` в JavaScript](#различия-между-let-const-и-var-в-javascript)
    - [Виды функций и их отличия, hoisting](#виды-функций-и-их-отличия-hoisting)
    - [Деструктуризация и оператор распространения](#деструктуризация-и-оператор-распространения)
      - [Оператор распространения (Spread Operator)](#оператор-распространения-spread-operator)
    - [Опциональная цепочка (Optional Chaining) и Опциональный оператор (Optional Mark)](#опциональная-цепочка-optional-chaining-и-опциональный-оператор-optional-mark)
    - [Работа с массивами](#работа-с-массивами)
    - [Строгий vs Нестрогий Сравнения](#строгий-vs-нестрогий-сравнения)
    - [Всплытие (Hoisting)](#всплытие-hoisting)
    - [Шаблонные Строки (Template Strings)](#шаблонные-строки-template-strings)
    - [Стрелочные функции vs Обычные функции](#стрелочные-функции-vs-обычные-функции)
    - [Temporary Dead Zone](#temporary-dead-zone)
    - [Использование "var" и поведение переменных без "var"](#использование-var-и-поведение-переменных-без-var)
    - [Что такое сборщик мусора? Зачем он нужен?](#что-такое-сборщик-мусора-зачем-он-нужен)
    - [Методы работы с объектами: Keys, Values, Entries, FromEntries](#методы-работы-с-объектами-keys-values-entries-fromentries)
    - [Методы работы с массивами: Flat, FlatMap, Includes, Array.from()](#методы-работы-с-массивами-flat-flatmap-includes-arrayfrom)
    - [Типы данных. Примитивные типы и ссылочные (объектные) типы](#типы-данных-примитивные-типы-и-ссылочные-объектные-типы)
    - [Преобразование Типов (Type Casting) и Принудительное Преобразование Типов (Type Conversion)](#преобразование-типов-type-casting-и-принудительное-преобразование-типов-type-conversion)
    - [Использование "typeof"](#использование-typeof)
    - [Как работает прототипное наследование](#как-работает-прототипное-наследование)
    - [Зачем нужно прототипное наследование](#зачем-нужно-прототипное-наследование)
    - [Цепочка прототипов](#цепочка-прототипов)
    - [Cвойства `__proto__` и `prototype`](#cвойства-__proto__-и-prototype)
    - [Создание объекта с прототипом](#создание-объекта-с-прототипом)
    - [Различие между прототипным и функциональным наследованием](#различие-между-прототипным-и-функциональным-наследованием)
    - [Где хранится ссылка на прототип](#где-хранится-ссылка-на-прототип)
    - [Создание недоступного объекта](#создание-недоступного-объекта)
    - [Методы из `Object.prototype`](#методы-из-objectprototype)
    - [Как работают замыкания](#как-работают-замыкания)

# Browser JS/TS

## JavaScript

### Циклы `while` и `for`

**Цикл `while`** используется для выполнения блока кода, пока условие оценивается как `true`. Синтаксис выглядит следующим образом:

```javascript
while (условие) {
  // блок кода, который будет выполнен
}
```

Пример:
```javascript
let i = 0;
while (i < 5) {
  console.log(i);
  i++;
}
```
Этот цикл будет выводить числа от 0 до 4 в консоль.

**Цикл `for`** чаще используется, когда известно количество итераций. Синтаксис:
```javascript
for (начало; условие; шаг) {
  // блок кода, который будет выполнен
}
```

Пример:
```javascript
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```
Аналогично предыдущему примеру, этот цикл выводит числа от 0 до 4.

### Условие `if`

Оператор `if` используется для выполнения блока кода, если заданное условие истинно.
```javascript
if (условие) {
  // блок кода, который будет выполнен, если условие истинно
}
```

Пример:
```javascript
let num = 10;
if (num > 5) {
  console.log("Число больше 5.");
}
```

### Конструкция `switch`

Оператор `switch` позволяет выполнять разные блоки кода в зависимости от условия.
```javascript
switch (выражение) {
  case x:
    // блок кода
    break;
  case y:
    // блок кода
    break;
  default:
    // блок кода
}
```

Пример:
```javascript
let fruit = "apple";
switch (fruit) {
  case "banana":
    console.log("Hello, banana!");
    break;
  case "apple":
    console.log("Hello, apple!");
    break;
  default:
    console.log("Unknown fruit.");
}
```

### Логические операторы

Логические операторы используются для создания условий, которые могут быть оценены как `true` или `false`.

- `&&` (И) - возвращает `true`, если оба операнда истинны.
- `||` (ИЛИ) - возвращает `true`, если хотя бы один из операндов истинен.
- `!` (НЕ) - инвертирует значение операнда.

Примеры:
```javascript
if (true && false) {
    console.log("Этот код не будет выполнен.");
}

if (true || false) {
    console.log("Этот код будет выполнен.");
}

if (!false) {
    console.log("Также этот код будет выполнен.");
}
```

### Условные операторы

Условные операторы (`? :`) позволяют сделать условное присваивание значений.

```javascript
const age = 19;
const status = (age >= 18) ? 'взрослый' : 'несовершеннолетний';
console.log(status); // Выведет "взрослый"
```

### Alert/prompt/confirm

- `alert` выводит сообщение и ждет, пока пользователь нажмет "ОК".
- `prompt` выводит диалоговое окно с запросом на ввод текста.
- `confirm` выводит диалоговое окно с запросом на подтверждение (ОК или Отмена).

```javascript
alert("Привет, мир!"); // Показывает сообщение
const age = prompt("Сколько вам лет?", 18); // Запрашивает и возвращает введенное значение
const isAdult = confirm("Вам есть 18?"); // Возвращает true, если нажата ОК, иначе false
```


### Различия между `let`, `const` и `var` в JavaScript

*Область видимости (Scope)*
Одно из ключевых отличий между `var`, `let` и `const` заключается в их области видимости.

- `var` объявляет переменную с функциональной областью видимости (function scope) или глобальной областью видимости, если объявлена вне функции.
- `let` и `const` объявляют переменные с блочной областью видимости (block scope), что означает, что они доступны только в рамках блока, в котором были объявлены (например, внутри цикла или условного блока).

Пример с `var`:

```javascript
if (true) {
  var a = 1;
}
console.log(a); // Выводит 1, потому что переменная a объявлена с помощью var и имеет функциональную область видимости.
```

Пример с `let`:

```javascript
if (true) {
  let b = 2;
}
console.log(b); // Выдаст ошибку ReferenceError: b is not defined, потому что b имеет блочную область видимости.
```

*Всплытие (Hoisting)*

- Переменные, объявленные с помощью `var`, "всплывают" в начало функции или глобального контекста, но инициализируются там, где были объявлены. Это значит, что их можно использовать до объявления в коде, но они будут `undefined` до момента инициализации.
- `let` и `const` также всплывают, но остаются во временной мертвой зоне (TDZ, Temporal Dead Zone) до их объявления, что делает их недоступными до момента объявления в коде.

Пример всплытия с `var`:

```javascript
console.log(x); // undefined
var x = 5;
```

Пример всплытия с `let`:

```javascript
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;
```

*Изменяемость (Mutability)*

- `let` позволяет изменять значение переменной после её объявления.
- `const` требует инициализации переменной при объявлении и не позволяет изменять её значение позже. Это делает `const` идеальным выбором для объявления констант.

Пример с `let`:

```javascript
let c = 3;
c = 4; // Допустимо
```

Пример с `const`:

```javascript
const d = 4;
d = 5; // TypeError: Assignment to constant variable.
```

Однако стоит отметить, что если `const` используется для объявления объекта или массива, то сам объект или массив может быть изменён (например, добавление или удаление элементов массива), но не сама переменная, указывающая на объект или массив.

```javascript
const e = [];
e.push(1); // Допустимо
e = [1]; // TypeError: Assignment to constant variable.
```

*Заключение*

- Используйте `let` для переменных, значение которых будет изменяться.
- Используйте `const` для переменных, значение которых не предполагается изменять, а также для объявления объектов и массивов, которые не будут переназначены.
- Избегайте `var` в современном JavaScript, поскольку `let` и `const` предоставляют более строгую и понятную область видимости.


### Виды функций и их отличия, hoisting

В JavaScript функции могут быть созданы разными способами, каждый из которых имеет свои особенности, в том числе по поводу области видимости, возможности использования до объявления (из-за механизма всплытия, или hoisting), а также this. Давайте рассмотрим основные типы функций в JavaScript и их отличия, а также поговорим о всплытии для функциональных объявлений.

*1. Функциональные объявления (Function Declarations)*

Функциональное объявление, или объявление функции, определяет функцию с указанным именем.

```javascript
function sum(a, b) {
  return a + b;
}
```

**Особенности:**
- **Всплытие (Hoisting):** Функциональные объявления полностью всплывают, что позволяет вызывать функцию до её объявления в коде.
- **Область видимости:** Такая функция доступна во всей области видимости, в которой была объявлена.

*2. Функциональные выражения (Function Expressions)*

Функциональное выражение создаёт функцию и присваивает её переменной. Функция может быть именованной или анонимной.

```javascript
const sum = function(a, b) {
  return a + b;
};
```

**Особенности:**
- **Всплытие:** Переменная, которой присвоено функциональное выражение, всплывает как обычная переменная. Это означает, что до выполнения строки с присваиванием функции переменная существует, но имеет значение `undefined`.
- **Область видимости:** Зависит от используемого ключевого слова (`var`, `let`, `const`).

*3. Стрелочные функции (Arrow Functions)*

Стрелочные функции представляют собой компактный способ создания функций. Они не имеют собственного контекста `this`, `arguments`, `super` или `new.target`.

```javascript
const sum = (a, b) => a + b;
```

**Особенности:**
- **Всплытие:** Так же, как и функциональные выражения, стрелочные функции всплывают в зависимости от объявленной переменной.
- **Область видимости и `this`:** Стрелочные функции заимствуют `this` из окружающего контекста на момент своего создания.

*Всплытие (Hoisting)*

**Функциональные объявления** всплывают полностью. Это означает, что функцию можно вызвать до её объявления в коде:

```javascript
console.log(sum(5, 3)); // Выведет 8

function sum(a, b) {
  return a + b;
}
```

**Функциональные выражения и стрелочные функции**, присвоенные переменным, всплывают по-другому. Переменная, которой должна быть присвоена функция, всплывает, но без инициализации функцией, что означает, что попытка вызвать функцию до её объявления приведёт к ошибке:

```javascript
console.log(sum(5, 3)); // TypeError: sum is not a function

const sum = function(a, b) {
  return a + b;
};
```

В случае использования `var` переменная будет всплывать и иметь значение `undefined` до выполнения присваивания:

```javascript
console.log(sum); // undefined
console.log(sum(5, 3)); // TypeError: sum is not a function

var sum = function(a, b) {
  return a + b

;
};
```
Эти отличия важны при выборе способа объявления функций в зависимости от того, как и где они будут использоваться в вашем коде.

### Деструктуризация и оператор распространения

*Деструктуризация (Destructuring Assignments)*

Деструктуризация позволяет локально распаковывать значения из массивов или свойства из объектов в переменные. Это упрощает работу с данными, избавляя от необходимости обращаться к ним напрямую через индексы массива или ключи объекта.

*Деструктуризация объектов:*

```javascript
const person = {
  name: 'Алексей',
  age: 30,
  position: 'Web Developer'
};

const { name, age } = person;
console.log(name); // Алексей
console.log(age); // 30
```

*Деструктуризация массивов:*

```javascript
const numbers = [1, 2, 3, 4, 5];
const [first, second] = numbers;

console.log(first); // 1
console.log(second); // 2
```

#### Оператор распространения (Spread Operator)

Оператор распространения позволяет расширить доступные для итерации элементы (например, массивы или строки) в местах, где ожидается ноль или более аргументов (для вызовов функций) или элементов (для массивов).

*Использование в массивах:*

```javascript
const first = [1, 2, 3];
const second = [4, 5, 6];

const combined = [...first, ...second];
console.log(combined); // [1, 2, 3, 4, 5, 6]
```

*Использование в объектах:*

```javascript
const person = { name: 'Алексей', age: 30 };
const updatedPerson = { ...person, position: 'Web Developer' };

console.log(updatedPerson);
// { name: 'Алексей', age: 30, position: 'Web Developer' }
```

### Опциональная цепочка (Optional Chaining) и Опциональный оператор (Optional Mark)

Опциональная цепочка `?.` позволяет безопасно читать значение глубоко вложенных свойств внутри объекта без необходимости явно проверять каждое из них на существование.

```javascript
const user = {
  profile: {
    name: 'Алексей',
    details: {
      age: 30
    }
  }
};

console.log(user.profile?.name); // 'Алексей'
console.log(user.profile?.address?.city); // undefined без выброса ошибки
```

Опциональный оператор `?.` предотвращает возникновение ошибки типа `TypeError`, если промежуточные свойства не существуют, вместо этого возвращая `undefined`.

*Опциональный вызов функции:*

Если не уверены, существует ли функция, можно использовать `?.()` для вызова.

```javascript
const user = {
  greet() {
    console.log('Привет!');
  }
};

user.greet?.(); // Привет!
user.sayGoodbye?.(); // Ничего не произойдет, функция не вызовется и не выдаст ошибку
```

Эти возможности языка значительно упрощают работу со сложными структурами данных и делают код более чистым и безопасным.

### Работа с массивами

*Map (Карта)*

Метод `map` создаёт новый массив, результатом выполнения функции на каждом элементе исходного массива.

```javascript
const numbers = [1, 2, 3, 4];
const squared = numbers.map(n => n * n);

console.log(squared); // [1, 4, 9, 16]
```

*Filter (Фильтр)*

Метод `filter` создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.

```javascript
const numbers = [1, 2, 3, 4];
const evens = numbers.filter(n => n % 2 === 0);

console.log(evens); // [2, 4]
```

*Reduce (Сокращение)*

Метод `reduce` применяет функцию к аккумулятору и каждому элементу массива (слева-направо), сводя его к одному значению.

```javascript
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((accumulator, current) => accumulator + current, 0);

console.log(sum); // 10
```

*Find (Найти)*

Метод `find` возвращает первый элемент в массиве, который соответствует предоставленному тестовому условию. Если ничего не найдено, возвращает `undefined`.

```javascript
const numbers = [1, 2, 3, 4];
const firstEven = numbers.find(n => n % 2 === 0);

console.log(firstEven); // 2
```

*Includes (Включает)*

Метод `includes` проверяет, содержит ли массив определённый элемент, и возвращает `true` или `false` соответственно.

```javascript
const numbers = [1, 2, 3, 4];
const includesTwo = numbers.includes(2);

console.log(includesTwo); // true
```

*Some (Некоторые)*

Метод `some` проверяет, удовлетворяет ли хотя бы один элемент в массиве условию, заданному в передаваемой функции.

```javascript
const numbers = [1, 2, 3, 4];
const hasOdd = numbers.some(n => n % 2 !== 0);

console.log(hasOdd); // true, потому что есть нечетные числа
```

Эти методы являются мощными инструментами для работы с массивами. Они делают код более чистым и понятным, избавляя от необходимости написания избыточных циклов `for` или `while` для обработки данных.

### Строгий vs Нестрогий Сравнения

В JavaScript существует два типа сравнений: строгие (`===`, `!==`) и нестрогие (`==`, `!=`). Основное отличие между ними заключается в том, как они обрабатывают сравнение разных типов данных.

*Нестрогие Сравнения (`==`, `!=`)*

Нестрогие сравнения (`==`, `!=`) автоматически приводят типы перед сравнением, что может привести к неочевидным результатам.

```javascript
console.log(1 == "1"); // true, число приводится к строке
console.log(0 == false); // true, 0 и false оба приводятся к false
console.log(null == undefined); // true, null и undefined считаются равными
```

Эти преобразования делают нестрогие сравнения менее предсказуемыми и потенциально более затруднительными в отладке.

*Строгие Сравнения (`===`, `!==`)*

Строгие сравнения (`===`, `!==`) проверяют равенство без приведения типа, т.е. значения считаются равными только если они одного типа и значения.

```javascript
console.log(1 === "1"); // false, разные типы
console.log(0 === false); // false, разные типы
console.log(null === undefined); // false, разные типы
```

Использование строгих сравнений предпочтительно для большинства сценариев, так как они обеспечивают более предсказуемое и надежное поведение.

### Всплытие (Hoisting)

Всплытие (hoisting) в JavaScript описывает поведение, при котором объявления переменных и функций перемещаются вверх их области видимости перед выполнением кода. Это важно понимать, поскольку влияет на доступность переменных и функций.

*Всплытие переменных*

Переменные, объявленные с помощью `var`, подвергаются всплытию, но их инициализация не всплывает.

```javascript
console.log(x); // undefined, а не ReferenceError
var x = 5;
```

Переменные, объявленные через `let` и `const`, также всплывают, но они находятся во временной мертвой зоне (Temporal Dead Zone, TDZ) до тех пор, пока не достигнут своего объявления, что делает их недоступными до объявления.

```javascript
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;
```

*Всплытие функций*

Функциональные объявления (function declarations) полностью всплывают, что позволяет вызывать функцию до её объявления в коде.

```javascript
console.log(sum(5, 3)); // 8
function sum(a, b) {
  return a + b;
}
```

Функциональные выражения (function expressions), назначенные переменным через `var`, `let`, или `const`, ведут себя как обычные переменные в отношении всплытия.

```javascript
console.log(sum); // undefined при var, ReferenceError при let или const
var sum = function(a, b) {
  return a + b;
};
```

Понимание всплытия помогает избежать ошибок, связанных с порядком объявления переменных и функций, и делает код более предсказуемым и надежным.

### Шаблонные Строки (Template Strings)

Шаблонные строки в JavaScript позволяют вставлять выражения в строковые литералы, обеспечивая более удобное форматирование и создание строк. Они заключаются в обратные кавычки (\` \`) вместо обычных одинарных или двойных кавычек и могут содержать местозаполнители, обозначаемые знаком доллара и фигурными скобками (`${expression}`).

*Пример:*

```javascript
const name = "Алексей";
const greeting = `Привет, ${name}!`;

console.log(greeting); // Выводит "Привет, Алексей!"
```

Шаблонные строки также поддерживают многострочный ввод, что делает их идеальными для создания больших блоков текста без необходимости использования символа переноса строки `\n`.

```javascript
const multiLineText = `Это строка,
которая переносится
на несколько строк`;
console.log(multiLineText);
```

### Стрелочные функции vs Обычные функции

Стрелочные функции (`=>`) были введены в ES6 и предлагают более сжатый синтаксис по сравнению с обычными функциями. Однако различия между стрелочными функциями и обычными функциями выходят за рамки синтаксиса.

*Синтаксис*

Стрелочная функция:

```javascript
const sum = (a, b) => a + b;
```

Обычная функция:

```javascript
function sum(a, b) {
  return a + b;
}
```

*`this` в контексте функций*

Одно из ключевых отличий — поведение ключевого слова `this`. В стрелочных функциях `this` заимствуется из окружающего контекста на момент их создания и не изменяется с помощью `call()`, `apply()` или `bind()`. В обычных функциях `this` может быть изменён, что делает их более гибкими в определённых ситуациях, но также может привести к ошибкам, если `this` используется неосторожно.

*Возврат значения*

Стрелочные функции с одним выражением возвращают значение этого выражения без использования слова `return`. В обычных функциях для возврата значения необходимо явно использовать `return`.

*Конструктор*

Стрелочные функции не могут быть использованы как конструкторы, и попытка сделать это приведёт к ошибке. Обычные функции могут быть использованы в качестве конструкторов.

*Аргументы*

Стрелочные функции не имеют собственного объекта `arguments`, в отличие от обычных функций. Однако можно достичь того же эффекта с помощью оператора распространения (`...args`).

```javascript
const func = (...args) => {
  console.log(args);
};
func(1, 2, 3); // Выведет [1, 2, 3]
```

Использование стрелочных функций по сравнению с обычными функциями зависит от контекста задачи: их компактность и поведение `this` могут быть предпочтительнее в одних ситуациях и ограничивающими в других.

### Temporary Dead Zone

**Temporary Dead Zone (TDZ)** — это термин, используемый для описания области кода, где переменные, объявленные с помощью `let` или `const`, не могут быть использованы до того момента, как они объявлены. Это явление возникает из-за блочной области видимости (`block scope`) этих переменных. TDZ начинается от начала блока, в котором объявлена переменная, и продолжается до её объявления.

Важно понимать, что TDZ относится к переменным, объявленным через `let` и `const`, и не применим к переменным, объявленным через `var`, так как последние подвергаются всплытию и имеют функциональную область видимости или область видимости всего скрипта, если они объявлены вне функций.

*Пример с `let`:*

```javascript
console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a = 3;
```

В этом примере переменная `a` находится в TDZ от начала блока до момента её объявления через `let`. Попытка обратиться к переменной перед её объявлением приводит к `ReferenceError`.

*Пример с `const`:*

```javascript
console.log(b); // ReferenceError: Cannot access 'b' before initialization
const b = 5;
```

Аналогично, переменная `b`, объявленная через `const`, находится в TDZ и не доступна до её объявления.

*Значение TDZ*

Понимание TDZ важно для избежания ошибок во время разработки. TDZ способствует более чистому и предсказуемому коду, так как гарантирует, что переменные не будут использоваться до их объявления. Это помогает предотвратить ошибки, связанные с использованием неинициализированных переменных, и делает структуру кода более понятной.

### Использование "var" и поведение переменных без "var"

*Использование "var"*

В JavaScript `var` используется для объявления переменных с функциональной областью видимости (function scope) или глобальной областью видимости, если объявление произошло вне функции. Основные особенности переменных, объявленных через `var`:

- **Всплытие (Hoisting):** Объявления переменных "всплывают" в начало функции или глобального контекста, но инициализация значения остается на месте объявления.
- **Переопределение:** Переменные, объявленные через `var`, могут быть переопределены в пределах одной и той же области видимости.
- **Функциональная или глобальная область видимости:** В отличие от `let` и `const`, которые имеют блочную область видимости, переменные `var` доступны во всей функции или глобально.

*Поведение переменных без "var" (или "let", "const")*

Когда переменная объявляется без использования `var`, `let` или `const`, она автоматически становится глобальной (если только не находится в строгом режиме "use strict", где такое действие приведет к ошибке). Это может привести к нежелательным последствиям, таким как загрязнение глобальной области видимости и конфликты имен переменных.

```javascript
function foo() {
  x = 10; // без 'var', 'let', или 'const'
}
foo();
console.log(x); // 10 - переменная стала глобальной
```

### Что такое сборщик мусора? Зачем он нужен?

Сборщик мусора (Garbage Collector, GC) — это механизм управления памятью, который автоматически освобождает память, занятую объектами, до которых невозможно достучаться или которые больше не используются в программе. GC важен для следующих причин:

- **Автоматизация управления памятью:** Программисту не нужно вручную управлять выделением и освобождением памяти, что снижает вероятность ошибок, таких как утечки памяти и двойное освобождение памяти.
- **Предотвращение утечек памяти:** Несмотря на то что сборщик мусора не может предотвратить все типы утечек памяти, он значительно снижает риск их возникновения, автоматически освобождая память от объектов, которые больше не доступны.
- **Упрощение разработки:** Управление памятью может быть сложным и подверженным ошибкам аспектом программирования. GC позволяет разработчикам сосредоточиться на логике приложения, не беспокоясь о деталях управления памятью.

В языках программирования, таких как JavaScript, сборщик мусора выполняет критически важную роль, управляя памятью автоматически. Это особенно важно в средах с ограниченными ресурсами, таких как веб-браузеры, где эффективное управление памятью может напрямую повлиять на производительность и отзывчивость приложений.

### Методы работы с объектами: Keys, Values, Entries, FromEntries

*Object.keys(obj)*

`Object.keys(obj)` возвращает массив из ключей собственных перечисляемых свойств переданного объекта.

```javascript
const person = { name: 'Алексей', age: 30 };
console.log(Object.keys(person)); // ["name", "age"]
```

*Object.values(obj)*

`Object.values(obj)` возвращает массив из значений собственных перечисляемых свойств объекта.

```javascript
console.log(Object.values(person)); // ["Алексей", 30]
```

*Object.entries(obj)*

`Object.entries(obj)` возвращает массив пар [ключ, значение] собственных перечисляемых свойств объекта.

```javascript
console.log(Object.entries(person)); // [["name", "Алексей"], ["age", 30]]
```

*Object.fromEntries(entries)*

`Object.fromEntries(entries)` преобразует список пар [ключ, значение] в объект. Это обратная операция к `Object.entries()`.

```javascript
const entries = [["name", "Алексей"], ["age", 30]];
console.log(Object.fromEntries(entries)); // { name: "Алексей", age: 30 }
```

### Методы работы с массивами: Flat, FlatMap, Includes, Array.from()

*Array.prototype.flat([depth])*

`flat()` создает новый массив, в котором все вложенные массивы рекурсивно "выпрямлены" до указанной глубины.

```javascript
const arr = [1, [2, [3, [4]]]];
console.log(arr.flat()); // [1, 2, [3, [4]]]
console.log(arr.flat(2)); // [1, 2, 3, [4]]
```

*Array.prototype.flatMap(callback)*

`flatMap()` сначала применяет функцию к каждому элементу массива, а затем выпрямляет результат до глубины 1. Это комбинация `map()` и `flat()`.

```javascript
const arr = [1, 2, 3];
console.log(arr.flatMap(x => [x, x * 2])); // [1, 2, 2, 4, 3, 6]
```

*Array.prototype.includes(valueToFind[, fromIndex])*

`includes()` определяет, содержит ли массив определенный элемент, и возвращает true или false соответственно.

```javascript
console.log(arr.includes(2)); // true
console.log(arr.includes(5)); // false
```

*Array.from(arrayLike[, mapFn[, thisArg]])*

`Array.from()` создает новый экземпляр массива из массивоподобного или итерируемого объекта. Может использоваться для преобразования строк, NodeList и других типов в массивы.

```javascript
const str = '123';
console.log(Array.from(str, num => Number(num))); // [1, 2, 3]
```

Эти методы являются частью современного стандарта ECMAScript и предоставляют разработчикам более эффективные и удобные инструменты для работы с данными в JavaScript.


### Типы данных. Примитивные типы и ссылочные (объектные) типы

В JavaScript существует две категории типов данных: **примитивные типы** и **ссылочные типы** (или типы-объекты).

*Примитивные типы данных*

Примитивные типы — это основные типы данных, которые представляют собой простые значения. К ним относятся:

1. **Number**: для числовых значений (например, `123` или `3.14`).
2. **String**: для текстовых данных (например, `"Привет, мир!"`).
3. **Boolean**: для логических значений `true` и `false`.
4. **Undefined**: тип для переменных, которым не было присвоено значение (например, объявленная переменная без значения).
5. **Null**: представляет собой "ничто" или "пустое значение".
6. **Symbol** (введен в ECMAScript 2015): уникальный и неизменяемый тип данных, используемый как ключ объекта.
7. **BigInt** (введен в ECMAScript 2020): для представления целых чисел произвольной точности, которые превышают предел `Number`.

Примитивы характеризуются тем, что они неизменяемы и работают по значению. Это означает, что когда вы работаете с примитивным типом данных, вы работаете непосредственно со значением этого типа.

*Ссылочные типы (Типы-объекты)*

Ссылочные типы или объекты представляют собой более сложные структуры данных. К ним относятся:

1. **Object**: базовый объект, от которого наследуются все остальные объекты.
2. **Array**: для представления упорядоченных коллекций данных.
3. **Function**: функции также являются объектами в JavaScript.
4. Специализированные объекты, такие как `Date`, `RegExp`, и различные встроенные объекты-обертки для примитивных типов, как `String`, `Number`, и `Boolean`.

Отличие ссылочных типов от примитивных заключается в том, что они работают по ссылке. Когда вы работаете с объектом, вы работаете не непосредственно со значением, а со ссылкой на значение. Это означает, что если у вас есть две переменные, ссылающиеся на один и тот же объект, изменения, внесенные через одну переменную, будут видны через другую.

*Основные различия между примитивными и ссылочными типами:*

- **Хранение в памяти**: Примитивы хранятся в стеке, что обеспечивает быстрый доступ к их значениям, в то время как ссылочные типы хранятся в куче, что может потребовать больше времени для доступа из-за необходимости разыменования ссылки.
- **Иммутабельность**: Примитивные значения неизменяемы (например, когда вы изменяете строку, создается новая строка, а старая остается без изменений), тогда как объекты могут быть изменены после создания.
- **Сравнение**: Примитивные значения сравниваются по их значению, тогда как ссылочные типы сравниваются по их ссылкам (адресу в памяти).
- **Копирование значений**: Копирование примитивного значения в другую переменную создает копию этого значения, в то время как копирование ссылочного типа в другую переменную создает вторую ссылку на тот же объект.

Понимание различий между примитивными и ссылочными типами данных важно для эффективной работы с переменными, функциями и объектами в JavaScript, а также для предотвращения ошибок, связанных с неожиданным поведением.

### Преобразование Типов (Type Casting) и Принудительное Преобразование Типов (Type Conversion)

В JavaScript часто возникает необходимость в преобразовании типов — явном или неявном изменении данных из одного типа в другой. Вот несколько советов и примеров, как решать задачи, связанные с преобразованием типов:

*Явное преобразование (Type Casting)*

Вы можете явно преобразовывать типы, используя встроенные функции и конструкторы, такие как `String()`, `Number()`, и `Boolean()`.

- **Преобразование в строку**: 
  ```javascript
  String(123); // "123"
  (123).toString(); // "123"
  ```
- **Преобразование в число**:
  ```javascript
  Number("123"); // 123
  parseInt("123", 10); // 123, с указанием системы счисления
  parseFloat("123.45"); // 123.45
  ```
- **Преобразование в булев тип**:
  ```javascript
  Boolean(1); // true
  !!1; // true, используя двойное отрицание
  ```

*Неявное преобразование (Type Coercion)*

JavaScript автоматически преобразует типы при выполнении арифметических операций, сравнений или в логическом контексте.

- **Строковое преобразование** происходит, когда вы используете оператор `+` с одним из операндов в виде строки:
  ```javascript
  "number: " + 123 // "number: 123"
  ```
- **Численное преобразование** происходит в математических операциях, кроме сложения, если один из операндов не является числом:
  ```javascript
  "123" - 23 // 100
  ```
- **Логическое преобразование** происходит в логическом контексте, например, в условных операторах:
  ```javascript
  if ("123") { ... } // true, потому что непустая строка преобразуется в true
  ```

*Советы по Решению Задач на Преобразование Типов*

1. **Ожидайте неочевидное**: JavaScript может вести себя неинтуитивно при неявном преобразовании типов, особенно при использовании `==` или при сложении строк и чисел. Лучше всегда использовать строгое сравнение (`===`) и явное преобразование типов.
2. **Проверяйте типы данных**: Используйте `typeof` для проверки и отладки типов данных переменных, особенно когда результат операции не соответствует ожиданиям.
3. **Используйте явное преобразование**: Чтобы избежать неожиданных результатов от неявного преобразования, предпочтительнее явно преобразовывать типы с помощью соответствующих функций и методов.

Понимание преобразования типов и умение контролировать этот процесс — ключевые навыки для успешного решения многих задач в JavaScript.

### Использование "typeof"

Оператор `typeof` в JavaScript позволяет определить тип значения переменной или выражения. Это может быть полезно для проверки типов данных во время выполнения программы.

```javascript
typeof "Hello, world!"; // "string"
typeof 123; // "number"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof {}; // "object"
typeof Symbol("id"); // "symbol"
typeof null; // "object" (это известная особенность JavaScript)
typeof function(){}; // "function"
```


### Как работает прототипное наследование

В JavaScript каждый объект имеет специальное скрытое свойство `[[Prototype]]` (как правило, доступное как `__proto__` или через методы `Object.getPrototypeOf()`/`Object.setPrototypeOf()`), которое ссылается на другой объект — его прототип. Когда вы пытаетесь получить доступ к свойству или методу объекта, и это свойство/метод в самом объекте отсутствует, JavaScript автоматически ищет его в прототипе. Если свойство/метод не найдено в прототипе, поиск продолжается по цепочке прототипов, пока не будет достигнут конец цепочки (обычно `Object.prototype`), после чего возвращается `undefined`.

*Пример прототипного наследования*

```javascript
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

rabbit.walk(); // Animal walk
alert(rabbit.eats); // true
```

В этом примере объект `rabbit` наследует свойство `eats` и метод `walk` от объекта `animal` через прототипное наследование.

### Зачем нужно прототипное наследование

1. **Повторное использование кода**: Прототипное наследование позволяет объектам делиться свойствами и методами, что способствует повторному использованию кода и уменьшает дублирование.

2. **Экономия памяти**: Объекты, наследующие свойства и методы через прототипы, используют меньше памяти, поскольку они не хранят собственные копии наследуемых свойств и методов, а используют общие, определённые в прототипе.

3. **Гибкость и динамичность**: Свойства и методы можно добавлять или изменять в прототипе в любой момент, и эти изменения автоматически станут доступны всем объектам, наследующим от этого прототипа. Это позволяет динамически модифицировать поведение объектов.

4. **Простота реализации сложных структур наследования**: В отличие от классической модели наследования, где структуры наследования могут стать очень сложными и громоздкими, прототипное наследование обеспечивает более простую и гибкую систему для создания связанных объектов.

Прототипное наследование является ключевым аспектом JavaScript и лежит в основе его объектно-ориентированных возможностей. Понимание этого механизма необходимо для эффективной работы с объектами, функциями и классами в JavaScript.

### Цепочка прототипов

Цепочка прототипов (prototype chain) в JavaScript — это механизм, благодаря которому объекты могут наследовать свойства и методы друг от друга. Этот механизм основан на том, что каждый объект имеет ссылку на свой прототип, а прототип, в свою очередь, также может иметь ссылку на свой прототип, создавая тем самым "цепочку" прототипов. Эта цепочка продолжается до тех пор, пока не будет достигнут прототип, который не имеет собственного прототипа (например, `Object.prototype`), и в этом случае поиск свойства или метода завершается.

*Как работает цепочка прототипов*

Когда вы пытаетесь обратиться к свойству или методу объекта, JavaScript сначала пытается найти это свойство или метод в самом объекте. Если свойство или метод не найдено, поиск продолжается в прототипе объекта, затем в прототипе прототипа и так далее вверх по цепочке прототипов, пока свойство или метод не будет найдено или пока не будет достигнут конец цепочки (т.е., `Object.prototype`).

Если после достижения конца цепочки свойство или метод так и не было найдено, операция возвращает `undefined`.

*Пример цепочки прототипов*

```javascript
let animal = {
  eats: true,
  walk() {
    console.log("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// вызов метода walk пройдет по цепочке прототипов: longEar -> rabbit -> animal
longEar.walk(); // Animal walk
console.log(longEar.jumps); // true (найдено в rabbit)
```

*Значение цепочки прототипов*

Цепочка прототипов является фундаментальным механизмом наследования в JavaScript и имеет несколько ключевых преимуществ:

- **Повторное использование кода**: Объекты могут наследовать общие свойства и методы от своих прототипов, что способствует сокращению дублирования кода.
- **Динамическое наследование**: Свойства и методы, добавленные или измененные в прототипе, автоматически становятся доступны всем объектам, находящимся ниже по цепочке прототипов.
- **Гибкость**: Цепочка прототипов позволяет создавать сложные иерархии наследования, обеспечивая при этом эффективное управление памятью и производительностью.

Цепочка прототипов является одной из самых мощных особенностей JavaScript, позволяя разработчикам строить сложные структуры на основе простых объектов, эффективно используя наследование и делегирование.

### Cвойства `__proto__` и `prototype`

В JavaScript свойства `__proto__` и `prototype` играют ключевую роль в прототипном наследовании, но они служат разным целям и используются в различных контекстах. Понимание различий между ними важно для эффективной работы с прототипным наследованием.

*`__proto__`*

Свойство `__proto__` — это геттер/сеттер, который позволяет читать или изменять прототип (т.е., внутреннее свойство `[[Prototype]]`) конкретного объекта. Это свойство не является частью стандарта ECMAScript до ES6, однако было реализовано во многих JavaScript движках как средство доступа к прототипу объекта.

```javascript
let animal = {
  eats: true
};

let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // Устанавливаем animal как прототип для rabbit

console.log(rabbit.eats); // true, так как свойство наследуется от animal
```

Важно отметить, что использование `__proto__` считается устаревшим, и рекомендуется использовать функции `Object.getPrototypeOf()` и `Object.setPrototypeOf()` для работы с прототипами объектов.

*`prototype`*

Свойство `prototype` существует только у функций-конструкторов и используется для определения объекта, который будет назначен в качестве прототипа для всех объектов, созданных с использованием этого конструктора при вызове с оператором `new`.

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.walk = function() {
  console.log(`${this.name} walks.`);
};

let animal = new Animal("Elephant");

animal.walk(); // Elephant walks.
```

Когда вы создаете новый объект с помощью `new Animal()`, созданный объект автоматически наследует свойства и методы из `Animal.prototype`, что позволяет всем объектам, созданным с использованием `Animal`, разделять метод `walk`.

*Основные различия*

- `__proto__` — это свойство любого объекта, указывающее на его прототип. С его помощью можно получить или установить прототип объекта.
- `prototype` — это свойство функций-конструкторов, определяющее объект, который будет назначен в качестве прототипа для объектов, созданных с использованием этой функции-конструктора.
- Использование `__proto__` считается устаревшим. Для работы с прототипами объектов предпочтительнее использовать `Object.getPrototypeOf()` и `Object.setPrototypeOf()`.
- `prototype` используется только в контексте функций-конструкторов для наследования свойств и методов новыми объектами.

Понимание этих различий помогает глубже освоить механизмы прототипного наследования в JavaScript и избегать распространенных ошибок при работе с объектами.

### Создание объекта с прототипом

В JavaScript существует несколько способов создания объекта с определенным прототипом:

*С помощью `Object.create`*

Метод `Object.create(proto, [propertiesObject])` создает новый объект с указанным объектом `proto` в качестве его прототипа и необязательным объектом `propertiesObject` для добавления собственных свойств.

```javascript
let animal = {
  eats: true,
  walk() {
    console.log("Animal walk");
  }
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true,
    enumerable: true // делаем свойство перечисляемым
  }
});

rabbit.walk(); // Animal walk
console.log(rabbit.jumps); // true
```

*С использованием конструктора и `prototype`*

Этот способ подразумевает создание функции-конструктора и определение свойств/методов в её свойстве `prototype`. Объекты, созданные с помощью оператора `new` и этой функции-конструктора, будут иметь указанный прототип.

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.walk = function() {
  console.log(`${this.name} walks.`);
};

let animal = new Animal("Elephant");
animal.walk(); // Elephant walks.
```

*Использование классов в ES6*

В ES6 введена синтаксическая обертка вокруг прототипного наследования — классы, которые позволяют более удобно работать с прототипами.

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  walk() {
    console.log(`${this.name} walks.`);
  }
}

class Rabbit extends Animal {
  jump() {
    console.log(`${this.name} jumps.`);
  }
}

let rabbit = new Rabbit("White Rabbit");
rabbit.walk(); // White Rabbit walks.
rabbit.jump(); // White Rabbit jumps.
```

Каждый из этих методов позволяет установить прототип для объекта, облегчая создание сложных иерархий наследования и повторное использование кода. Выбор метода зависит от конкретных требований к проекту и личных предпочтений разработчика.

### Различие между прототипным и функциональным наследованием

В JavaScript основной механизм наследования — это прототипное наследование, но существует также идея функционального (или замыкания) наследования. Давайте рассмотрим ключевые отличия между этими двумя подходами.

*Прототипное наследование*

Прототипное наследование в JavaScript позволяет объектам наследовать свойства и методы от других объектов через цепочку прототипов. Это достигается за счёт использования внутреннего свойства объекта `[[Prototype]]`, которое ссылается на другой объект, прототип.

- **Эффективность**: Способствует экономии памяти, так как методы хранятся в одном экземпляре в прототипе и доступны всем объектам, наследующим этот прототип.
- **Гибкость**: Позволяет динамически изменять прототипы, добавлять или удалять свойства/методы в реальном времени.

Пример:

```javascript
let animal = {
  walk() {
    console.log("Animal walk");
  }
};

let rabbit = Object.create(animal);
rabbit.walk(); // Animal walk
```

*Функциональное наследование*

Функциональное наследование использует замыкания для наследования и инкапсуляции свойств и методов. Это подход, при котором используются функции для создания объектов и замыкания для хранения приватных данных.

- **Инкапсуляция**: Позволяет скрыть детали реализации и создать приватные свойства и методы, недоступные извне.
- **Наследование**: Осуществляется путём расширения и дополнения объекта новыми свойствами и методами.

Пример:

```javascript
function Animal(name) {
  let animal = {};
  animal.name = name;
  animal.walk = function() {
    console.log(`${animal.name} walks`);
  };
  return animal;
}

let rabbit = Animal("Rabbit");
rabbit.walk(); // Rabbit walks
```

Этот подход обеспечивает большую гибкость и контроль над инкапсуляцией данных, но может быть менее эффективным в плане использования памяти, поскольку каждый объект хранит свои собственные копии методов.

*Получение и установка прототипа объекта*

Для работы с прототипами объектов в JavaScript существуют специализированные методы:

*Получение прототипа объекта*

- `Object.getPrototypeOf(obj)`: Возвращает прототип указанного объекта `obj`.

*Установка прототипа объекта*

- `Object.setPrototypeOf(obj, prototype)`: Устанавливает прототип (`prototype`) указанному объекту `obj`.

Пример использования:

```javascript
let animal = {
  eats: true
};

let rabbit = {
  jumps: true
};

// Установка прототипа для rabbit
Object.setPrototypeOf(rabbit, animal);

// Получение прототипа объекта rabbit
console.log(Object.getPrototypeOf(rabbit) === animal); // true

rabbit.eats; // true, наследуется от animal
```

Эти методы предоставляют удобный интерфейс для работы с прототипами объектов, но следует помнить о потенциальном влиянии на производительность при их частом использовании.

### Где хранится ссылка на прототип

В JavaScript каждый объект имеет скрытое свойство `[[Prototype]]`, которое является его прототипом. Это свойство не доступно напрямую из JavaScript кода начиная с ECMAScript 5, но до этого стандарта многие движки JavaScript предоставляли доступ к нему через свойство `__proto__`. В современном JavaScript рекомендуется использовать методы `Object.getPrototypeOf()` и `Object.setPrototypeOf()` для чтения и изменения прототипов объектов соответственно.

### Создание недоступного объекта

В ECMAScript 5 был введен метод `Object.create(null)`, который создает объект без прототипа. Такой объект не наследует ничего от `Object.prototype`, что делает его "чистым" словарем, идеально подходящим для использования в качестве простого ключ-значение хранилища без риска случайного наследования методов или свойств.

Пример создания недоступного объекта:

```javascript
let map = Object.create(null);
map.key = "value";
console.log(map.key); // "value"
// map.toString не существует, так как нет наследования от Object.prototype
```

Этот подход обеспечивает создание объекта, который не имеет доступа к стандартным методам объекта, делая его "недоступным" в обычном понимании.

### Методы из `Object.prototype`

`Object.prototype` является прототипом для всех объектов и предоставляет базовый набор методов, доступных для всех объектов в JavaScript. Некоторые из этих методов включают:

- **`toString()`**: Возвращает строковое представление объекта. По умолчанию возвращает `"[object Type]"`, где `Type` — тип объекта.
- **`hasOwnProperty(propName)`**: Возвращает `true`, если свойство с именем `propName` существует в объекте как собственное (не унаследованное через цепочку прототипов) свойство.
- **`isPrototypeOf(object)`**: Проверяет, является ли объект прототипом для другого объекта.
- **`valueOf()`**: Возвращает примитивное значение указанного объекта. В большинстве случаев просто возвращает сам объект.

Эти методы обеспечивают основную функциональность для всех объектов в JavaScript и могут быть переопределены для изменения поведения наследуемых объектов. Важно помнить, что переопределение этих методов, особенно `toString()` и `valueOf()`, может влиять на работу вашего кода в разных контекстах, например, при приведении типов или строковом представлении объектов.


Замыкание (closure) в программировании — это функция, со всеми переменными, которые были в её области видимости в момент создания. Это одна из ключевых концепций JavaScript и многих других языков программирования, позволяющая функции доступ к переменным из области, в которой она была объявлена, даже после того, как эта область выполнения завершила свою работу.

### Как работают замыкания

В JavaScript функции имеют доступ к переменным, которые находятся в той же области видимости. Замыкание создаётся в момент, когда функция объявляется, позволяя этой функции "запомнить" и иметь доступ к своей лексической области видимости, даже когда она выполняется вне своей первоначальной области видимости.

*Пример замыкания*

```javascript
function createCounter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}

let counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

В этом примере, `createCounter` возвращает функцию, которая увеличивает переменную `count` и возвращает её значение. Каждый раз, когда мы вызываем `counter()`, переменная `count` увеличивается, и это работает благодаря механизму замыканий. Функция возвращаемая из `createCounter` сохраняет ссылку на переменную `count` своей "родительской" функции.

*Проблемы, которые решают замыкания*

1. **Инкапсуляция данных**: Замыкания позволяют скрыть переменные внутри функции, делая их недоступными извне и тем самым предоставляя приватность данных.

2. **Сохранение состояния**: Замыкания позволяют сохранять состояние между вызовами функции, что полезно для создания счётчиков, аккумуляторов и других конструкций, требующих поддержания состояния.

3. **Каррирование и частичное применение функций**: Замыкания позволяют легко реализовать каррирование и частичное применение функций, что делает возможным создание новых функций на основе существующих с предзаданными аргументами.

4. **Модульность и управление зависимостями**: Замыкания могут использоваться для создания модулей и "классов" в JavaScript, обеспечивая упорядоченную и легко управляемую структуру кода.

Замыкания являются мощным инструментом в арсенале разработчика, позволяя реализовывать различные паттерны проектирования, управлять состоянием и обеспечивать инкапсуляцию данных в JavaScript и многих других языках программирования.